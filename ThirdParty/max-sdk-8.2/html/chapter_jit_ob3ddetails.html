<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Max API: OB3D Details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Max API
   &#160;<span id="projectnumber">8.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('chapter_jit_ob3ddetails.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">OB3D Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this chapter is to fill in additional details of Jitter OpenGL, which we refer to as OB3Ds.</p>
<p>We will show how to disable and/or override default OB3D attributes and methods, how to support matrix input and output, and manage resources such as textures, display lists, and shaders. This chapter assumes familiarity with the OpenGL API and the OB3D Quick Start chapter. It is out of the scope of our documentation to cover the OpenGL API, so for information on the OpenGL API we recommend consulting the OpenGL Red Book and the many online tutorials.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_classdef"></a>
Defining the OB3D Jitter Class</h1>
<p>As covered in the OB3D Quick Start, Jitter OB3Ds have a large number of default attributes and methods, and require some specific methods to be defined. This section seeks to clarify these common attributes and methods and how to achieve custom behavior where necessary.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_draw"></a>
Declaring a Draw Method</h1>
<p>All Jitter OB3Ds must define a method bound to the symbol ob3d_draw. This method takes no arguments in addition to the object struct, and should be defined with the private <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature. The private ob3d_draw method will be called by the standard draw, and drawraw methods that are added to every OB3D. The draw method will set up OpenGL state associated with the default OB3D attributes before calling ob3d_draw, while the drawraw method will not.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_geom"></a>
Declaring Destination and Geometry Related Methods</h1>
<p>It is possible for attributes of a Jitter OB3D or your render destination to change, requiring resources to be freed or rebuilt. There are three methods used to communicate to an OB3D which such events happen so that the OB3D can manage resources accordingly. They are: dest_closing, which informs an OB3D that the destination is being freed, and any context dependent resources such as textures, display lists, and shaders should be freed; dest_changed, which informs an OB3D that the destination has been rebuilt, and new resources can be allocated; and rebuild_geometry, which informs an OB3D of a change in texture units or some other attribute which affects jit_gl_drawinfo_setup() and other <a class="el" href="structt__jit__gl__drawinfo.html" title="t_jit_gl_drawinfo struct used for tasks such as multi texture unit binding.">t_jit_gl_drawinfo</a> related functions, such as jit_gl_texcoord, requiring geometry that uses such functions to be rebuilt. These methods take no arguments in addition to the object struct. The dest_closing and dest_changed methods should be defined with the private <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature, and the rebuild_geometry method is typically defined as typed, but without arguments, so that users have the ability to explicitly call, if deemed necessary. The jit.gl.gridshape SDK project is a good example of these methods as it needs to free and allocate a display list as the render destination changes, and also makes use of jit_gl_texcoord to support multi-texturing, requiring geometry to be rebuilt as the number of texture units or other attributes change.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_reg"></a>
Declaring a Register Method</h1>
<p>Since all Jitter OB3D objects are named to support reference by name in jit.gl.sketch, and other objects, it is necessary to add the default registration method, <a class="el" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef" title="Registers an object in the named object registry.">jit_object_register()</a>. Object registration and notification are covered in detail in a future chapter.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_rot"></a>
Overriding Rotation and Scale Related Attributes</h1>
<p>By default, each Jitter OB3D has rotate, rotatexyz, scale, and viewalign attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble() function to set up OpenGL state prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a5794356b6e680fc42ec03985d1692467" title="ob3d flag">JIT_OB3D_NO_ROTATION_SCALE</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glMatrixMode, glTranslate, glRotate, and glScale.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_color"></a>
Overriding Color Related Attributes</h1>
<p>By default, each Jitter OB3D has color, aux_color, and smooth_shading attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a7f84484673e1241bd9bf6a788424e264" title="ob3d flag">JIT_OB3D_NO_COLOR</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glColor and glShadeModel.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_texture"></a>
Overriding Texture Related Attributes</h1>
<p>By default, each Jitter OB3D has texture, capture, tex_map, tex_plane_s, and tex_plane_t attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble() function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a466aeb904a4940caa25ef2bd65d98d5a" title="ob3d flag">JIT_OB3D_NO_TEXTURE</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glTexGen, jit_gl_bindtexture, jit_gl_unbindtexture, jit_gl_begincapture, and jit_gl_endcapture.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_lighting"></a>
Overriding Lighting and Material Related Attributes</h1>
<p>By default, each Jitter OB3D has lighting_enable, auto_material, shininess, mat_ambient, mat_diffuse, mat_specular, and mat_emission attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a64a16642863ff9ee0f3be60a5a409747" title="ob3d flag">JIT_OB3D_NO_LIGHTING_MATERIAL</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glLight, glLightModel, and glMaterial.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_fog"></a>
Overriding Fog Related Attributes</h1>
<p>By default, each Jitter OB3D has fog and fog_params attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34ad2ec8bc9be8405095e51aed5562e4351" title="ob3d flag">JIT_OB3D_NO_FOG</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable, glHint, and glFog.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_poly"></a>
Overriding Polygon Variable Related Attributes</h1>
<p>By default, each Jitter OB3D has poly_mode, cull_face, point_size, and line_width attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34ac0ee9631f29aa6ff138ef8aa27401102" title="ob3d flag">JIT_OB3D_NO_POLY_VARS</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glPolygonMode, glEnable, glCullFace, glPointSize, and glLineWidth.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_blend"></a>
Overriding Blending Related Attributes</h1>
<p>By default, each Jitter OB3D has blend_mode and blend_enable attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a6f83c15c9a5d0ae5a641ade6846398fc" title="ob3d flag">JIT_OB3D_NO_BLEND</a> flag. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable and glBlendFunc.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_aa"></a>
Overriding Depth Buffer and Antialiasing Related Attributes</h1>
<p>By default, each Jitter OB3D has depth_enable and antialias attributes added to the class by jit_ob3d_setup(), and these attributes are used in your ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34aad5ce56d55f9acbf89c142ce71c8b005" title="ob3d flag">JIT_OB3D_NO_DEPTH</a> and <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a86f1b09fafab7f8cf85eb05f9ea233ed" title="ob3d flag">JIT_OB3D_NO_ANTIALIAS</a> flags, respectively. You can override these attributes by defining your own attributes of the same name, however, you will need to manage any necessary OpenGL state inside of your own draw method with the appropriate calls to glEnable and glHint.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_matout"></a>
Overriding Matrixoutput and Automatic Attributes</h1>
<p>By default, each Jitter OB3D has matrixoutput and automatic attributes added to the class by jit_ob3d_setup(), and these attributes are used in the ob3d_draw_preamble function prior to calling your object's draw method. These attributes can be disabled by using the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a2a87c51ca41ac903ce7202be7330d943" title="ob3d flag">JIT_OB3D_NO_MATRIXOUTPUT</a> and <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34ac5452087c4b7e7782b8e962bb850bf00" title="ob3d flag">JIT_OB3D_AUTO_ONLY</a> flags, respectively. You can override these attributes by defining your own attributes of the same name.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_ui"></a>
Declaring a User Interface Object</h1>
<p>It is possible to declare a user interface OB3D, such as jit.gl.handle. To do so, you must use the <a class="el" href="group__jitter.html#gaf92dfdfa93c2cfae5bfec82eef9a7b34a8db9a004d2076dc83fc35c98a31e7a80" title="ob3d flag">JIT_OB3D_DOES_UI</a> flag to jit_ob3d_setup(), and define a method bound to the symbol ob3d_ui, with the private <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args">A_CANT</a> type signature and prototype similar to the following example from jit.gl.handle:</p>
<div class="fragment"><div class="line">t_jit_err jit_gl_handle_ui(t_jit_gl_handle *x,</div>
<div class="line">   <a class="code" href="structt__line__3d.html">t_line_3d</a> *p_line, <a class="code" href="structt__wind__mouse__info.html">t_wind_mouse_info</a> *p_mouse);</div>
<div class="ttc" id="astructt__line__3d_html"><div class="ttname"><a href="structt__line__3d.html">t_line_3d</a></div><div class="ttdoc">Line or line segment in 3D space (GLfloat)</div><div class="ttdef"><b>Definition:</b> jit.gl.common.h:160</div></div>
<div class="ttc" id="astructt__wind__mouse__info_html"><div class="ttname"><a href="structt__wind__mouse__info.html">t_wind_mouse_info</a></div><div class="ttdoc">t_wind_mouse_info_struct provided by jit.window and jit.pwindow mouse events</div><div class="ttdef"><b>Definition:</b> jit.gl.common.h:122</div></div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_ob3ddetails_jitclassctor"></a>
The Jitter Class Constructor and Destructor</h1>
<p>Inside your Jitter class constructor, you must call jit_ob3d_new() with a pointer to your newly allocated object, and your render destination name. The jit_ob3d_new() function allocates an opaque structure that stores the standard OB3D attributes and some additional OB3D state, initializing them to default values, and then setting the pointer at the byte offset specified when calling the jit_ob3d_setup() function in your class definition. If your object supports matrix output or simply uses the <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> structure when drawing, you should typically allocate your initial <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> in your constructor using the jit_glchunk_new() or jit_glchunk_grid_new() functions. Use of the <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> structure and matrix output is described later in this chapter. Similarly, your OB3D Jitter class destructor must call jit_ob3d_free() to free the opaque structure used for common OB3D state, free any allocated instances of <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> with jit_glchunk_free(), and free any other resources allocated such as display lists or textures.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_ob3ddraw"></a>
The OB3D Draw Method</h1>
<p>The ob3d_draw method is where all the drawing in your object should take place. It is also where you should typically allocate context dependent resources or query the context state, since you know that your context is valid and has been set. For the most part, the drawing you will perform in your ob3d_draw method will be pure and simple OpenGL, though there are a few caveats which we will cover.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_glstruct"></a>
The t_jit_glchunk Structure and Matrix Output</h1>
<p>Since Jitter is a general purpose matrix processing framework, it makes sense that you would have the ability to pass geometry information through a Jitter network as matrices if your geometry is well suited to a matrix representation. The cells of your matrix can hold vertex information such as position, texture coordinates, normal vectors, color, and edge flags, and are documented in the "Geometry Under The Hood" Jitter Tutorial. You also have the option of specifying a connections matrix to reference the connectivity of the vertices if it is not implicit in the matrix representation, and a drawing primitive to use when drawing the vertices.</p>
<p>All this information, and whether or not the geometry matrix should be rendered immediately or sent through the Jitter network is managed with the <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a>. An SDK example which demonstrates the use of <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> is jit.gl.gridshape. The <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> structure along with the vertex matrix it contains is allocated by the jit_glchunk_new() or jit_glchunk_grid_new() functions, freed with the jit_glchunk_delete() function, and drawn with the jit_ob3d_draw_chunk() function. For reference, the <a class="el" href="structt__jit__glchunk.html" title="t_jit_glchunk is a public structure to store one gl-command&#39;s-worth of data, in a format which can be...">t_jit_glchunk</a> structure and relevant chunk flags are provided below:</p>
<div class="fragment"><div class="line"><span class="comment">// jit_glchunk is a public structure to store one</span></div>
<div class="line"><span class="comment">// gl-command&#39;s-worth of data, in a format which</span></div>
<div class="line"><span class="comment">// can be passed easily to glDrawRangeElements.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_glchunk</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a>   *prim;         <span class="comment">// GL_TRI_STRIP, GL_TRIANGLES, etc.</span></div>
<div class="line">   <a class="code" href="structt__object.html">t_jit_object</a> *m_vertex;      <span class="comment">// jit_matrix of xyzst... data.</span></div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a>    *m_vertex_name;   <span class="comment">// vertex matrix name</span></div>
<div class="line">   <a class="code" href="structt__object.html">t_jit_object</a> *m_index;      <span class="comment">// optional 1d connection matrix</span></div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a>    *m_index_name;   <span class="comment">// connection matrix name</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m_flags;      <span class="comment">// special flags</span></div>
<div class="line">   <span class="keywordtype">void</span>      *next_chunk;      <span class="comment">// singly linked list, typically NULL</span></div>
<div class="line">} <a class="code" href="structt__jit__glchunk.html">t_jit_glchunk</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// flags for chunk creation</span></div>
<div class="line"><span class="preprocessor">#define JIT_GL_CHUNK_IGNORE_TEXTURES      1 &lt;&lt; 0</span></div>
<div class="line"><span class="preprocessor">#define JIT_GL_CHUNK_IGNORE_NORMALS      1 &lt;&lt; 1</span></div>
<div class="line"><span class="preprocessor">#define JIT_GL_CHUNK_IGNORE_COLORS      1 &lt;&lt; 2</span></div>
<div class="line"><span class="preprocessor">#define JIT_GL_CHUNK_IGNORE_EDGES      1 &lt;&lt; 3</span></div>
<div class="ttc" id="astructt__jit__glchunk_html"><div class="ttname"><a href="structt__jit__glchunk.html">t_jit_glchunk</a></div><div class="ttdoc">t_jit_glchunk is a public structure to store one gl-command's-worth of data, in a format which can be...</div><div class="ttdef"><b>Definition:</b> jit.gl.chunk.h:37</div></div>
<div class="ttc" id="astructt__object_html"><div class="ttname"><a href="structt__object.html">t_object</a></div><div class="ttdoc">The structure for the head of any object which wants to have inlets or outlets, or support attributes...</div><div class="ttdef"><b>Definition:</b> ext_mess.h:191</div></div>
<div class="ttc" id="astructt__symbol_html"><div class="ttname"><a href="structt__symbol.html">t_symbol</a></div><div class="ttdoc">The symbol.</div><div class="ttdef"><b>Definition:</b> ext_mess.h:102</div></div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_ob3ddetails_caveats"></a>
OB3D OpenGL Caveats</h1>
<p>While you can use any standard Open GL calls inside of your ob3d_draw method. There are a few things worth noting to follow Jitter conventions. The first of which is the binding of texture coordinates. Since Jitter OB3Ds support multi-texturing by default, it is not necessarily satisfactory to submit only one texture coordinate with glTexCoord. Jitter provides some utility routines to set the texture coordinates for as many texture units which are bound, jit_gl_texcoord(1/2/3)(f/fv). Determining how many texture units have been bound by the default OB3D attributes requires some overhead, so rather than perform this overhead with every jit_gl_texcoord call, the jit_gl_texcoord functions take a <a class="el" href="structt__jit__gl__drawinfo.html" title="t_jit_gl_drawinfo struct used for tasks such as multi texture unit binding.">t_jit_gl_drawinfo</a> struct as an argument. This struct can be setup once before rendering many vertices with the jit_gl_drawinfo_setup function. Example use of jit_gl_texcoord and jit_gl_drawinfo_setup is in the jit.gl.videoplane SDK project. Another Jitter specific mechanism is the means to bind textures using named instances of jit.gl.texture. It is possible to create and bind your own textures in an OB3D, but you must then perform all maintenance instead of relying on jit.gl.texture to handle this work for you. To bind and unbind an instance of jit.gl.texture, you should call the jit_gl_bindtexture and jit_gl_unbindtexture functions, which take a <a class="el" href="structt__jit__gl__drawinfo.html" title="t_jit_gl_drawinfo struct used for tasks such as multi texture unit binding.">t_jit_gl_drawinfo</a> argument, a symbol with the name of the jit.gl.texture instance, and an integer for which texture unit to bind. Unlike binding ordinary textures in OpenGL, it is important to unbind instances of jit.gl.texture, or else problems may arise.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_attrinfo"></a>
Getting Information About the OB3D Attributes</h1>
<p>Though the default OB3D attributes are typically relevant to the code which is automatically handled for your object prior to calling the ob3d_draw method, it is sometimes necessary to access these values. Since the default OB3D attributes are stored in an opaque ob3d struct member, they are not accessible by your object with a simple struct pointer dereference. Instead, you need to use the jit_attr_get* functions to access these attributes. You should pass in your object struct as the first argument to these functions rather than your ob3d struct member. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> pos[3];</div>
<div class="line"><a class="code" href="group__attrmod.html#ga5282561e957ac1c113abf448250293da">jit_attr_getfloat_array</a>(x,<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;position&quot;</span>),3,pos);</div>
<div class="ttc" id="agroup__attrmod_html_ga5282561e957ac1c113abf448250293da"><div class="ttname"><a href="group__attrmod.html#ga5282561e957ac1c113abf448250293da">jit_attr_getfloat_array</a></div><div class="ttdeci">long jit_attr_getfloat_array(void *x, t_symbol *s, long max, float *vals)</div><div class="ttdoc">Retrieves attribute value as an array of floating point values.</div><div class="ttdef"><b>Definition:</b> jit.attribute.util.c:280</div></div>
<div class="ttc" id="agroup__symbol_html_ga5d8db08b384aeb76eaee85a15f46fbcb"><div class="ttname"><a href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a></div><div class="ttdeci">t_symbol * gensym(C74_CONST char *s)</div><div class="ttdoc">Given a C-string, fetch the matching t_symbol pointer from the symbol table, generating the symbol if...</div></div>
</div><!-- fragment --><p>Note that if you are acquiring this value often, it is preferable to generate the symbol in advance rather than generate the symbol for every call.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_context"></a>
Getting Information About the Context</h1>
<p>From within the ob3d_draw, dest_closing, and dest_changed methods, the rendering context has always been set, and you can get a handle to the native context using either the aglGetCurrentContext or wglGetCurrentContext functions. One can also in these methods use standard OpenGL glGet* functions to determine the context's OpenGL state, such as the viewport, transformation matrix. It is not recommended to try and acquire the native context from other methods, or query the OpenGL state as it may not be valid.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_play"></a>
Playing Well with Others</h1>
<p>It is important to recognize that OpenGL state is persistent, and that there may be objects which rely on OpenGL state that are drawn after your object draws itself. If your object makes any changes to OpenGL state that might affect objects that follow, you should restore the OpenGL state to whatever it was before your routine was called. For example, if your object changes the texture transformation matrix, you should push and pop the texture transformation matrix with glMatrixMode, glPushMatrix, and glPopMatrix, to prevent any problems with other objects.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_wrapdef"></a>
Defining the OB3D Max Wrapper Class</h1>
<p>As mentioned in the OB3D Quick Start, in your Max wrapper class definition, you need only add a call to the max_ob3d_setup() function to add your standard drawing methods, and the max_jit_ob3d_assist() function as your assist method, unless you wish to define your own custom assist method. Everything else is similar to the standard technique of wrapping a Jitter Class demonstrated in the Max Wrapper Class chapter. Please consult the OB3D Quick Start chapter and the jit.gl.simple SDK project for all necessary information related to the OB3D Max wrapper class.</p>
<h1><a class="anchor" id="chapter_jit_ob3ddetails_matin"></a>
Matrix Input</h1>
<p>Sometimes it is desirable for an OB3D also support incoming matrices as is the case with jit.gl.videoplane or jit.gl.mesh. It is not recommended to mix and match OB3Ds with MOPs. Conflicts arise with respect to arguments, standard inlets and outlets. Instead, if you wish to support matrix input in your OB3D, you should simply add to your Jitter class a method bound to the symbol jit_matrix, and handle the incoming matrix data according to your needs - for example as texture data in the case of jit.gl.videoplane, or geometry data in the case of jit.gl.mesh. The jit.gl.videoplane SDK project provides an example of an OB3D which also supports matrix input. When it is necessary to have multiple input matrices, this is typically managed by either declaring alternately named methods for each input, or exposing an attribute that specifies which input the jit_matrix method assumes it is being called with. Note that this requires additional logic within the Max wrapper class to map to inlets, as it is not handled automatically. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
